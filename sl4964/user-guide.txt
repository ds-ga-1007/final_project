Musical Style Classifier PackageTeam members: Wenjie Sun (ws854)Shasha Lin (sl4964)Kate Pei-chen Wu (pcw271)User GuideThis program trained a binary classifier and uses it to judge, on the fly, if an midi audio file has more Jazz influence or Classical influence in its musical style.  We highly suggest you download a song in midi format, from websites such as freemidi.org, and see what the classifier tells you about its musical style. Run the project from terminal: change directory to the folder titled Midi, and run main.py. We have included some midi files in our package as an alternative to testing your own midi files. You will be prompted to make a choice between seeing results from these built-in audio files or input your own midi file. If you choose to see results from built-in songs, you will be asked to pick a number and we will show you the result of classification for that song, as well as a visualization of how different instruments were used in this song across its play time. If you choose to use your own midi file, you will be prompted to type in the directory of that file (e.g. /Users/ShashaLin/Downloads/Filename.mid), and we will analyze that file with our trained classifier, generating the classification result of its musical style, as well as visualizing its velocity and musical note arrangement in time, or across different channels. You can do this for multiple songs until you are tired of it and type in ‘quit’.

*Depending on your python configuration, you may need to pip install Mido package, which is used for parsing midi files, before the package could be run smoothly.Documentation	1.     Class path_list: Provide a function that allows users to input a master folder that is structured as …/GenreType/ArtistName and output a list of path to every midi files. The function will throw any non-midi files.2.     Class midi_to_dataframe:Provide a function that allows users to input a file path and output a dataframe. If users input a second parameter as “1” (optional), then this function will also partition the path for GenreType and ArtistName into the dataframe.During the process:1)    The function will map the note_id in midi format to octave2)    The function will map the program_id in midi format to which instrument and its type in each track (as well as handle the special case for track 10, which is reserved for special instruments)3.     Class process_masterProvide a function that inputs a master folder (mentioned in function 1) and minimum number of tracks.During the process:1)    The function will use path_list and midi_to_dataframe to convert the midi file and merge all midi files into one dataframe2)    The function will only take midi files that have more than minimum tracks determined in the function.  4. Classifer.pyfeatureExtration:Processes midi file from raw dataframe into text data, before feeding into TF-IDF vectorizer.classify:Was never called on the fly, but was used before deployment to train the vectorizers from our 121 classical songs and 76 jazz songs. When we trained and tested the classifier with 80-20% train-test split, we achieved .92 accuracy and .99 auc. Trained model are dumped as .pkl files, to be loaded for prediction.5. Classify.pyLoads the fitted TF-IDF vectorizers and trained SVM classifer to make the prediction. toPredict function Returns an array of binary results. 1 being Jazz and 0 being Classical.6. ThreeD_plot.pyvisual_Vel takes in the midi dataframe, and visualizes the music’s pitch and volume in 3D space, as a function of time sequence.7. TwoD_plot.pyProvides 6 plotting modules that, respectively, plots the highest and lowest octaves in each channel, the most frequently used instruments as a pie chart, the time-length rank of each channels as a histogram, as well as the pitch and volume of each channel of the picked song.